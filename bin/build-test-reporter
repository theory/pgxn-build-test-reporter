#!/usr/bin/env perl -w

use strict;
use warnings;
use v5.30;

Reporter->new(@ARGV)->go;

package Reporter;
use strict;
use warnings;
use v5.30;
use IPC::Run qw(run);
use Config ();
use Symbol qw(gensym);
use JSON;
use TOML::Parser;
use Getopt::Long;
use WWW::PGXN;
use File::Path qw(make_path);
use File::Basename;
use Parallel::Subs;

sub new {
    Getopt::Long::Configure(qw(no_ignore_case bundling));
    my $self = bless {
        input_file  => 'data/distributions.txt',
        output_file => 'data/results.txt',
        work_dir    => 'work',
        verbose     => 1,
        pg_config   => $ENV{PG_CONFIG},
        pgxn        => WWW::PGXN->new( url => 'https://api.pgxn.org/' ),
    } => __PACKAGE__;
    Getopt::Long::GetOptions(
        @_,
        'input-file|in=s'   => \$self->{input_file},
        'output-file|out=s' => \$self->{output_file},
        'work-dir|dir=s'    => \$self->{work_dir},
        'verbose|v+'        => \$self->{verbose},
    ) or die "Usage: $0 --in INPUT_FILE --out OUTPUT_FILE\n";

    $self->{pg_config} ||= _find_pg_config();
    $self->status(2, "## Using $self->{pg_config}");

    $self->{pg_version} = _pg_version($self->{pg_config});
    $self->status(2, "## Using PostgreSQL $self->{pg_version}\n");

    return $self;
}

sub status {
    my ($self, $lvl, $msg) = @_;
    say $msg unless $lvl > $self->{verbose};
}

sub go {
    my $self = shift;
    open my $in, '<:encoding(UTF-8)', $self->{input_file}
        or die "Cannot open $self->{input_file}: $!\n";
    open my $out, '>raw', $self->{output_file}
        or die "Cannot open $self->{output_file}: $!\n";

    make_path $self->{work_dir};
    chdir $self->{work_dir} || die "Cannot chdir into $self->{work_dir}\n";

    my $callback = sub {
        my $rec = shift;
        say {$out} encode_json $rec;
        $self->status(1, "## $rec->{package} " . ($rec->{success} ? "ok" : "not ok"))
    };
    my $p = Parallel::Subs->new(max_process => 16);

    my $i = 0;
    while (<$in>) {
        $i++;
        chomp;
        my ($name, $version) = split /\s+/;
        die "Error parsing $_\n" unless $name && $version;
        $p->add(sub { $self->pgxn_build($name, $version) }, $callback);
        last if $i == 4;
    }

    $p->wait_for_all;
}

sub pgxn_build {
    my ($self, $name, $version) = @_;
    $self->status(1, "## Build $name $version");
    my $dist = $self->{pgxn}->get_distribution($name, $version) or do {
        $self->status(0, "### Cannot find $name $version on PGXN; skipping");
        return;
    };

    my $rec = {
        package  => $name,
        version  => $version,
        os       => $^O,
        postgres => $self->{pg_version},
        arch     => $Config::Config{myarchname},
        success  => JSON::false,
        steps    => [],
    };

    $self->status(2, "### Downloading $name $version");
    $dist->download_to('.');

    my $file = basename $dist->download_path;
    return $rec unless $self->_run($rec, "unzip $file", qw(unzip -o), $file);
    my $dir = $file =~ s/\.zip$//r;
    chdir $dir or die "Cannot chdir into $dir: $!\n";
    return $self->build($rec);
}

sub build {
    my ($self, $rec) = @_;
    if (-e 'Cargo.toml') {
        $self->pgrx_build($rec);
    } elsif (-e 'Makefile' || -e 'makefile' || -e 'GNUmakefile' || -e 'Configure' || -e 'configure') {
        $self->pgxs_build($rec);
    } else {
        $rec->{reason} = "Could not determine build pipeline";
    }
    return $rec;
}

sub pgxs_build {
    my ($self, $rec) = @_;
    $rec->{pipeline} = 'pgxs';
    if (-e 'Configure') {
        return unless $self->_run($rec, 'configure', qw(./Configure));
    } elsif (-e 'configure') {
        return unless $self->_run($rec, 'configure', qw(./configure));
    }
    my @vars = ("PG_CONFIG=$self->{pg_config}");
    return unless $self->_run($rec, 'make', qw(make), @vars);
    return unless $self->_run($rec, 'make install', qw(make install), @vars);
    return unless $self->_run($rec, 'make installcheck', qw(make installcheck), @vars);
    $rec->{success} = JSON::true;
}

sub pgrx_build {
    my ($self, $rec) = @_;

    local $ENV{CARGO_TERM_COLOR} = 'never';
    local $ENV{NO_COLOR} = 'true';

    $rec->{pipeline} = 'pgrx';
    my $cfg = TOML::Parser->new->parse_file('Cargo.toml');

    # Look for pgrx.
    my $pgrxv = $cfg->{dependencies}{pgrx} || die "pgrx not found in Cargo.toml\n";
    $pgrxv =~ s/^=//;

    return unless $self->_run(
        $rec, 'cargo install cargo-pgrx',
        qw(cargo install --locked cargo-pgrx --version), $pgrxv,
    );

    return unless $self->_run(
        $rec, 'cargo pgrx init',
        qw(cargo pgrx init), "--pg$self->{pg_version}=$self->{pg_config}",
    );

    return unless $self->_run(
        $rec, 'cargo pgrx package',
        qw(cargo pgrx package --test --pg-config), $self->{pg_config},
    );

    return unless $self->_run(
        $rec, 'cargo test',
        qw(cargo test --all --no-default-features --features),
        "pg$self->{pg_version} pg_test", qw(-- --nocapture),
    );

    $rec->{success} = JSON::true;
}

sub _run {
    my ($self, $rec, $name, @cmd) = @_;
    $self->status(2,  "### $rec->{package}: $name");
    run \@cmd, \undef, '>pipe', (my $pipe = gensym), '2>&1';
    push @{ $rec->{steps} } => {
        name    => $name,
        command => \@cmd,
        exit    => $? >> 8,
        output  => [ map { chomp; $_ } <$pipe> ],
    };

    return 1 if $? == 0;
    $self->status(2, "### $rec->{package}: $name failed");
    $rec->{reason} = "$name failed";
    return 0;
}

sub _find_pg_config {
    run [qw(which pg_config)], \undef, \my $out or die "pg_config not found\n";
    chomp $out;
    return $out;
}

sub _pg_version {
    my $pg_config = shift;
    run [$pg_config, '--version'], \undef, \my $out or exit $? >> 8;
    $out =~ /(\d+)/ or die "No version found in $pg_config --version output:\n$out";
    return $1;
}
